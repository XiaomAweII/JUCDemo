# Java内存模型（Java Memory Model，JMM）

为了屏蔽掉各种硬件以及操作系统之间的内存访问差异，以实现让Java程序在各个平台都能够保证一致的访问效果，Java虚拟机规范当中定义了Java内存模型。

Java内存模型是一种规范，规范了Java虚拟机与计算机内存之间是如何协同工作的。它**规定了一个线程如何和何时看到线程修改过的访问共享变量的值，以及在必须时如何同步的访问共享变量的值**。

![2.3Java内存模型图.png](imgs/2.3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9B%BE.png)

可以看到，由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。在明确Java内存模型时做什么之后，具体来看一下Java内存模型：

首先我们需要弄懂上图当中的两个JVM，内存分配的两个概念，一个是堆heap，一个是栈stack。Java里的堆，它是一个运行时的数据区，堆是由垃圾回收来负责的。堆的优势是可以动态的分配内存大小，生成期也不必实现告诉编译器，因为它是在运行时的动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但是也有缺点，它的缺点由于是要在运行时动态分配内存，因此它的存取速度相对慢一些。

接着是栈，它的优势是存取速度比堆要快，仅次于计算机里边的寄存器。栈的数据是可以共享的，但是它的缺点，是存在栈中的数据大小与生存期必须时确定的，缺乏灵活性。栈中主要存放一些基本类型的变量，比如我们小写的int、short、long、byte、float、double、boolean、char和对象。Java内存模型，在于它要求调用栈和本地变量存放在线程栈上，这里的thread stack对象存放在堆上。具体看一下，一个本地变量，它也可能是指向一个对象的引用，这种情况下引用本地变量，它是存放在线程栈上，但是对象本身是存放在堆上的。一个对象，它可能包含方法，我们的method one和two这些方法可能包含本地变量，这里边的local variable one和two，这些本地变量，它仍然是存放在线程栈上的，即使这些方法所处的对象存放在堆上；一个对象的成员变量可能会随着这个对象自身存放在堆上，不管这个成员变量是原始类型还是应用类型；静态成员变量跟随着类的定义一起存放在堆上，存放在堆上的对象可以被所有持有堆这个对象引用的线程访问，这里边如果我们这个thread它存放了object three的，这个引用，那么它是可以访问它的。

当一个线程可以访问一个对象的时候，它也可以访问这个对象的成员变量；如果两个线程同时调用同一个对象上的同一个方法，它们都将会访问这个对象的成员变量。但是，每一个线程都拥有了这个成员变量的私有拷贝，这个很重要，就是如果两个线程，这里比方说图中两个线程同时调用了一个对象-Object3，它们都拥有的是这个成员变量的私有拷贝，记住！这里是私有拷贝。

<hr>

![2.3计算机硬件架构简单图示.png](imgs/2.3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%AE%80%E5%8D%95%E5%9B%BE%E7%A4%BA.png)

现在看到的是计算机硬件架构的一个简单图示，首先需要介绍的是CPU，这里面是一个多CPU，一个现代计算机通常有两个或者多个CPU。其中，一些CPU还有多核，从这一点可以看出，在一个有两个或者多个CPU的现代计算机上同时运行多个线程是非常有可能的，而且每个CPU在某一个时刻运行一个线程是肯定没有问题的，这就意味着如果你的Java程序是多线程的，在你的Java程序中，每个CPU上一个线程是可能同时并发执行的。

介绍完多CPU，接着是CPU寄存器，每个CPU都包含一系列的寄存集，它们是CPU内存的基础，CPU在寄存器上执行操作的速度远大于在主存上执行的速度，这是因为CPU访问寄存器的速度远大于主存。

接着来看高速缓存cache，由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现在计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高级缓存，来作为内存与处理器之间的缓冲，将运算需要使用到的数据复制到缓存中，让运算能快速的进行，当运算结束后，再从缓存同步回内存之中。这样处理器就无需等待缓慢的内存，读写了。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还是要慢一点，每个CPU可能有一个CPU的缓存层，一个CPU还有多层缓存，在某一时刻，一个或者多个缓存行可能被读到缓存，一个或者多个缓存行可能再被刷新回主存，同一时间点可能会有很多操作在这里面。

接着是内存，一个计算机还包含一个主存，所有的CPU都可以访问主存。主存通常比CPU中的缓存大得多。

接下来看一下运作原理，通常情况下，当一个CPU需要读取主存的时候，它回将主存的部分读取到CPU缓存中，它甚至可能将缓存的部分内容读到它的内存寄存器里面，然后寄存器中执行操作，当CPU需要将结果回写到主存的时候，它回将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。

<hr>

![2.3Java内存模型与硬件内存架构关联图.png](imgs/2.3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84%E5%85%B3%E8%81%94%E5%9B%BE.png)

接下来看下Java内存模型与硬件的内存架构之间的关联，通过图可以看出来在Java内存模型与硬件内存架构之间是存在一些差异的。硬件内存架构，它没有区分线程栈和堆，对于硬件而言，所有的线程栈和堆都分布在主内存里面，部分线程栈和堆可能有时候回出现在CPU缓存中和CPU内部的寄存器里边。

<hr>

![2.3Java内存模型抽象架构图.png](imgs/2.3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%8A%BD%E8%B1%A1%E6%9E%B6%E6%9E%84%E5%9B%BE.png)

再从抽象的角度来看一下线程和主内存之间的抽象的关系，线程之间共享变量，它存储在我们的主内存里面，每个线程都有一个私有的本地内存。本地内存，它是Java内存模型的一个抽象概念，它并不真实存在，它涵盖了缓存写缓冲区、寄存器以及其他的硬件和编译器的优化。本地内存中，它存储了该线程已读或者写的共享变量的拷贝副本，比如这里面线程A如果要使用主内存的一个变量，那么它先拷贝出来这个变量的一个副本放在自己的本地内存里。

从更低的层次来说，主内存就是硬件的内存，是为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存有限存储于寄存器和高速缓存中。Java内存模型中，线程的工作内存是CPU的寄存器和高速缓存的一个抽象描述，而JVM的静态内存存储模型就是我们说的JVM内存模型，它只是一种对内存的物理划分而已，它只局限在内存，而且只局限在JVM的内存。现在，如果线程间通信，它要求必须要经过主内存，如果线程A和线程B之间要通信的话，必须要经历下面两个步骤：

第一步是线程A要把本地内存A种更新过的共享变量，刷新到主内存里面去。线程B到主内存中去读取线程A之前已经更新过的共享变量。

说完这个许多人已经意识到之前计数问题当中的技术功能问题出现在哪里。我们来推演一下，假设主内存中当前变量的值为1，线程A和线程B，同时开始执行，先说线程A，线程A从主内存里面拿到的变量的值是1，存到自己的本地内存A里面，然后执行+1的操作，线程A计算完之后得到的结果为2，然后将它写回到主内存变量变成2，这个是线程A的过程。

同时执行的线程B，是如何执行的呢？线程B从主内存拿到的值也是1，存到线程B的本地内存B里面，然后执行+1操作，最后变成2。在线程A将2写回到主内存的同时呢，线程B也开始讲自己计算后的结果写回到主内存，而不是先读取到线程A的2之后再重新计算。

这两个计算的过程中，两个系统间的数据，它们是互相不可见的，因此计数就出现了错误，这个时候我们就必须增加一些同步的手段来保证并发时程序处理的准确性。

<hr>

接下来看下Java内存模型定义的同步的八种操作和规则，先看下文字，后边再看下图示：

**八种操作**

- **lock（锁定）**：作用于主内存的变量，把一个变量标识为一条线程独占状态
- **unlock（解锁）**：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
- **read（读取）**：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
- **load（载入）**：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中
- **use（使用）**：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个使用变量的值的字节码指令时执行这个操作
- **assign（赋值）**：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
- **store（存储）**：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write操作使用
- **write（写入）**：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中

**同步规则**

- 如果要把一个变量从主内存中复制到工作内存，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行，也就是说，read与load之间、store与write之间是可能插入其他指令的。
- 不允许read和load、store和write操作之一单独出现，也就是说read操作后如果load操作没有执行，工作内存中的变量值是不确定的；同理，store操作后如果write操作没有执行，主内存中的变量值也是不确定的。
- 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存中
- 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作
- 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现
- 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
- 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定住的变量
- 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）

![2.3Java内存模型八种操作和规则.png](imgs/2.3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%85%AB%E7%A7%8D%E6%93%8D%E4%BD%9C%E5%92%8C%E8%A7%84%E5%88%99.png)

这些同步操作和对应的基本规则是Java里并发相关的类在设计时都必须遵守的，这里需要简单注意一点是，这样一层模型还有一些特殊的规则。这样一层模型还有一些特殊的规则，实际用到时候再去介绍，比如我们现在知道的就是final修饰的一些值是不允许修改的，类似于这样中隐性规则等等。