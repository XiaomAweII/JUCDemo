# 多线程并发拓展

## 死锁

死锁，指的是两个或两个以上的进程在执行过程中，因争夺资源而造成一种互相等待的现象。如果没有外力作用，它们就将无法推进下去，此时就称系统处于死锁状态或者系统产生了死锁。这些永远在互相等待的进程成为死锁进程，由于资源占用，它是互斥的，当某个进程提出申请资源后，使得有关进程在无外力的协助下永远分配不到必须的资源而无法继续前进，这就产生了一种特殊现象的死锁。

大学学过操作系统，哲学家就餐问题，这也是一个典型的死锁问题。虽然线程在运行过程中可能发生死锁，但是死锁的发生也具备一定条件，接下来，看一下死锁产生必须具备的四个必要条件。

### 死锁 - 必要条件

1. 互斥条件：进程对所分配到的资源进行排他性使用，即在一段时间内，某资源只由一个进程占用，如果此时还有其他进程请求资源，那么请求者只能等待知道占有资源的进程用完，释放出来才可以
2. 请求与保持条件：指进程已经保持了一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程阻塞，但又对自己已获得其他资源保持不放
3. 不剥夺条件：指线程已经获得资源，在未使用完之前不能被剥夺，只在使用完时自己释放
4. 环路等待条件：发生在死锁时，一定存在一个进程，它是资源的一个环形的链

只要上述四个条件之一不满足，就不会发生死锁。

```java
package com.xiaomaweii.example.deadLock;

import lombok.extern.slf4j.Slf4j;

/**
 * 一个简单的死锁类
 * 当DeadLock类的对象flag==1时（td1），先锁定o1,睡眠500毫秒
 * 而td1在睡眠的时候另一个flag==0的对象（td2）线程启动，先锁定o2,睡眠500毫秒
 * td1睡眠结束后需要锁定o2才能继续执行，而此时o2已被td2锁定；
 * td2睡眠结束后需要锁定o1才能继续执行，而此时o1已被td1锁定；
 * td1、td2相互等待，都需要得到对方锁定的资源才能继续执行，从而死锁。
 *
 *
 * @author xiaoweii
 * @create 2025-03-09 22:05
 */
@Slf4j
public class DeadLock implements Runnable {
    public int flag = 1;
    // 静态对象是类的所有对象共享的
    private static Object o1 = new Object(), o2 = new Object();

    @Override
    public void run() {
        log.info("flag:{}", flag);
        if (flag == 1) {
            synchronized (o1) {
                try {
                    Thread.sleep(500);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                synchronized (o2) {
                    log.info("1");
                }
            }
        }
        if (flag == 0) {
            synchronized (o2) {
                try {
                    Thread.sleep(500);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                synchronized (o1) {
                    log.info("0");
                }
            }
        }
    }

    public static void main(String[] args) {
        DeadLock td1 = new DeadLock();
        DeadLock td2 = new DeadLock();
        td1.flag = 1;
        td2.flag = 0;
        //td1,td2都处于可执行状态，但JVM线程调度先执行哪个线程是不确定的。
        //td2的run()可能在td1的run()之前运行
        new Thread(td1).start();
        new Thread(td2).start();
    }
}

```

### 如何避免死锁

第一种是加锁顺序线程，一定要按照一定顺序进行加锁。

第二种技术是加速实现，系统在尝试着获取锁的时候，可以加上一定的时间，查过时间的时候，那么就放弃对该锁的请求，并释放自己的锁，让其他线程有机会使用该锁。

第三种技术是死锁检测，死锁检测说起来容器，做起来比较难，实际中一般也不会有人单独去写代码去做死锁检测，死锁检测，是一种比较好的死锁预防的机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。每当一个线程获得的锁会在线程和锁相关的数据结构当中记下来，初次之外，每当线程请求锁也需要记录在这个数据结构中。当一个线程请求锁失败的时候，这个线程可以遍历锁的关系图，看是否有死锁发生，并决定后续操作该怎么办，具体这个结构，需要根据实际情况自己去设计。那么当检测出死锁的时候，线程都可以做那些事情呢？一个可行的做法是释放所有锁，回退，并且等待一段时间后，这个时间是随机的，之后进行重试，这个和简单的加锁超时有些类似，不一样的是只有死锁发生了才会回退，而不会因为加锁请求超时了。虽然有了回退和等待，但是如果有大量线程又同时竞争，同一批锁它们还是有可能出现重复的死锁，这时候，有一种好的方案是给线程设置优先级，让一个或几个线程回退，剩下的线程就像没发生死锁一样，继续保持着它们需要的锁，如果赋予这些线程的优先级是固定不变的，同一个线程总是会拥有更高的优先级。为了避免这个问题，我们可以在死锁发生的时候，设置随机的线程优先级。

