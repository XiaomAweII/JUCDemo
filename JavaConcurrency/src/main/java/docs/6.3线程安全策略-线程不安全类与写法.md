# 线程不安全类与写法

线程不安全的类，简单来说如果一个类的对象同时可以被多个线程访问，那么它就很容易表现出线程不安全的现象，比如抛出异常、逻辑处理错误等等，这种类就被称之为线程不安全类

首先看下注册拼接

- StringBuilder -> StringBuffer

虽然StringBuffer是线程安全的，但是在实现的时候，使用了synchronized关键字，它会导致这个方法同一时间只有一个线程可以调用，导致它在性能上是有损耗的，涉及到多线程的时候可以考虑StringBuffer来处理，至少结果是可以保证的，但是很多时候在做字符串拼接，可能是在一个方法里面，单独定义一个StringBuilder的变量来进行注册拼接，这个时候就不会去选择StringBuffer了。因为在一个方法内部定义局部变量进行使用的时候，属于堆栈封闭，这个时候只有单个线程可以操作这个对象，就不涉及线程安全的问题了，这个时候优先选择不需要进行同步锁的StringBuilder对象，这样性能有所提升，相对StringBuffer来讲计算会更快，这就是为什么Java同时提供了线程安全和不安全的两个字符串拼接的类。

- SimpleDateFormat -> JodaTime

JodaTime本质上并不属于Java提供的，需要引入一个新的包

推荐使用JodaTime提供的DateTime，相比之前的SimpleDateFormat，实际处理上有更多的优势。

- ArrayList、HashSet、HashMap 等 Collections

线程不安全的类不止这些

- 先检查再执行：if(condition(a)) { handle(a) }

为什么说先检查再执行是线程不安全的呢？
先假设a是一个线程安全的类，假设是atomic对应的一个对象，在这里面，判断的时候，可能两个线程都访问到了，这个if判断都通过了，接下来分别去处理，这时候就会触发线程不安全的问题。这里的不安全在于它分成了两个操作之后，即使之前的一个过程，是线程安全的，后一个操作也是线程安全的。但是它俩的间隙过程中，不是原子性的，因此会引发线程不安全问题。可以回顾下atomic自增的时候，在底层实现通过cas原理保证它能完全达到原子性的更新。实际项目过程中，如果遇到要判断一个对象是否满足的时候，满足某个条件再做处理的时候，一定要多考虑这个对象是否是多线程共享的，如果这个对象是多线程共享的，那么一定要在它上面加个锁，或者保证它里面的两个操作是原子性的才可以，否则的话是容易触发线程不安全的。
