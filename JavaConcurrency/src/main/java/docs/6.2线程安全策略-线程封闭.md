# 线程安全策略-线程封闭

不可变对象，在某些情况下将不会修改的类对象，设计成不可变对象，让对象在多个线程间保证对象是线程安全的。归根到底，这相当于我们躲避开并发这个问题。实现好的并发，真是一件很难的事情，所以很多时候，我们都想躲避并发，避免并发。除了设计成不可变对象，其实还有一个简单的方法，就是线程封闭。

什么是线程封闭呢？其实就是把对象封装到一个线程里，只有这一个线程能看到这个对象，那么这个对象就算不是线程安全的，也不会出现任何线程安全方面的问题了，因为它只能在一个线程里进行访问。

那么如何实现线程封闭呢？

- Ad-hoc 线程封闭：程序控制实现，最糟糕。忽略。完全靠实现者控制的线程封闭，脆弱，尽量少用。
- 堆栈封闭：局部变量，无并发问题。遇到最多，简单来说，就是局部变量，多个线程访问一个方法的时候，方法中的局部变量都会被拷贝一份到线程的栈当中，所以局部变量是不会被多个线程所共享的，因此也就不会出现并发问题。（详见Java内存模型）所以能用局部变量别用全局变量，是全局变量不是全局常量。之前不用并发，大部分程序是OK的，主要是因为大部分需求是在方法内定义局部变量，通过堆栈封闭来实现的。
- ThreadLocal 线程封闭：特别好的封闭方法。（可以学习下ThreadLocal的源码，ThreadLocal内部维护了一个map，map的key是每个线程的名称，而map的值就是要封闭的对象，每一个线程中的对象都对应着一个map中的值，也就是说ThreadLocal利用map实现了对象的线程封闭）

这里通过ThreadLocal结合LoginFilter实现登录过滤器，实现将用户信息存储到ThreadLocal里面，在请求对应的线程，任何有需要获取当前登录用户信息的地方都可以很方便的取出来。由于它们之间是线程封闭的，因此也不需要担心线程安全问题。

为什么要这样设计呢？正常每一个请求其实对应服务器来讲都是一个线程在运行。我们希望线程间隔离，那么首先，这个线程在被后端服务器进行实际处理的时候，我们通过一个filter，可以直接先取出来当前用户，然后把数据存到ThreadLocal当中。当这个线程被我们接口的service以及其他helper等相关的类进行处理的时候，很有可能在某些点就需要取出当前用户，这个时候，我们就可以随时随地的从ThreadLocal当中直接拿之前存储过的值，这样用起来就很方便。

如果不这样做，会有什么麻烦呢？这个时候因为登录用户通常是从request中取出来的，因此，我们可能需要带着request或者从request里面取出来的用户信息，然后从controller上开始不停的往下传，甚至可能会传到一些util类里面。这样会导致代码不断处理很不舒服，而这里如果使用了ThreadLocal加上filter，就可以很方便的在接口处理之前，先取出相关的信息，在接口实际处理的时候，什么时候需要什么时候从ThreadLocal里面把信息取出来就可以了。这样的话，我们的代码在设计的时候也变得容易多了，不至于把一个类从controller一直传下去，传的过程中，还需要把相关的信息传递下去。让我们的方法里面额外参杂一些我们不想传输的变量。

<hr>

对于线程封闭计数，有一个常见应用，但是大家都不知道，但是提起名字，大家肯定都是用过，那就是数据库连接对应的JDBC Connection对象，了解Connection对象的话，可能知道它在是现实并没有针对线程安全做太多处理。在JDBC的规范里，也没有要求Connection对象必须时线程安全的，实际在服务及应用程序中，线程从线程池中获取了一个Connection对象，使用完之后，再将对象返回给连接池。由于大多数请求都是单线程采用同步的方式来处理的，并且在Connection对象返回之前，连接池不会将它分配非其他线程，因此，这种连接管理模式在处理请求时隐含的将Connection对象封闭在线程中。这样使用的可再生对象，虽然本身不是线程安全的，但是它通过线程封闭也做到了线程安全。