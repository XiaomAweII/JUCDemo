# 线程安全性-有序性

## 有序性

- 在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性
- volatile、synchronized、lock

> synchronized、lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然保证了有序性。另外Java内存模型具有一些先天的有序性，即不需要通过任何手段就能能够保证有序性，这个通常被称为happens
> before原则。如果两个操作的执行次序无法从happens before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。

## happens before原则（先行发生原则）

总共设计八条原则，详见《深入理解Java虚拟机》这本书

1. 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。

> 对于程序次序规则来说，简单理解为一段程序代码的执行顺序，在单个线程中看起来是有序的。注意，虽然这条规则中提到，书写在前面的操作先行发生于书写在后面的操作，这个应该是程序看起来的执行顺序是按照代码的顺序执行的。因为虚拟机可能会对程序代码进行指令重排序。虽然进行了重排序，但是最终执行的结果是与程序顺序执行的结果是一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有次序的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。

2. 锁定原则：一个unLock操作先行发生于后面对同一个锁的lock操作

> 锁定原则，也就是说，无论在单线程中还是多线程中，同一个锁如果处于被锁定状态，那么必须先对锁进行释放操作，后面才能继续进行lock操作。

3. volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作

> 这条规则是一条比较重要的规则，它标志着volatile保证了线程可见性。通俗地讲就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作一定是先行发生于读操作的。关于volatile变量规则，在可见性里对volatile这个关键字进行了详解。如果不是很懂，可以看下volatile读写操作插入内存屏障和禁止重排序的CPU指令示意图。

4. 传递原则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C

> 前四条规则，在happens before当中是比较重要的，后四条就显而易见了

5. 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作

> 这条规则是比较容易理解的，就是在一个线程中，必须先执行了Thread的start()方法，然后才会执行其他的代码。

6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生

> 必须在执行了interrupt()方法之后，才会执行检测到中断事件发生。

7. 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行

8. 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始

> 线程终结和对象终结这两条规则主要是介绍线程和对象的相关操作要在终结之前完成


<hr>

总结：如果两个操作的执行次序不能从happens before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。

