# FutureTask

FutureTask组件是JUC里面的，但是它不是AQS的子类。但是这个类对线程结果的处理很值得我们学习和项目中使用，因此，这里来看一下。

在学习Java的时候，应该都学习过Thread和Runnable。创建一个线程，通常有两种方式，一种是直接继承Thread，另一种就是实现Runnable接口，这两种方式有一个共同的缺陷就是在执行完任务之后无法获取执行结果。从java1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。接下来呢，就看一下Callable、Future和FutureTask三个类的使用方法。

## Callable与Runnable接口对比

首先对比下Callable和Runnable这两个接口，Runnable的代码非常简单，它是一个接口，只有一个方法，就是run方法，创建一个类，实现它，把一些费时的操作写在里面，然后使用某个线程去执行该Runnable实现类，就可以实现多线程。Callable的代码，也非常简单，不同的是它是一个泛型接口，它有一个call函数，call函数的返回类型就是创建Callable对象时指定的类型。学习Callable，对应着Runnable能很快理解他，Callable和Runnable的功能大致相似，Callable的功能更强大一些，主要是它被线程执行后可以有返回值，并且能够抛出异常。

## Future

Future，也是一个接口，对于我们具体的Runnable或者Callable的一个任务，它可以进行取消查询的任务，是否被取消查询，是否完成以及获取结果等等。通常线程都是属于异步计算模型的，所以通常不可能直接从别的线程中得到方法的返回值，这个时候Future就出场了，Future可以监视目标线程调用call的情况，当调用Future的get方法的时候，就可以获得它的结果，这个时候通常线程可能不会直接完成，当前线程就会开始阻塞，直到call方法结束返回结果，线程才继续执行。总结一句话，Future可以得到别的线程任务方法的返回值。

## FutureTask

接下里看一下FutureTask类，它的父类是RunnableFuture，而RunnableFuture又是一个接口，它继承了Runnable和Future这两个接口，因此，就可以知道FutureTask最终也是执行Callable类型的任务，如果构造函数参数是Runnable的话，它会转换成Callable类型的任务，然后再执行。这个Task实现了两个接口Runnable和Future，所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。那么这个组合有什么好处呢？假设有一个很费时的逻辑需要计算，并且返回这个值，同时这个值又不是马上需要，那么就可以使用这个组合，用另外一个线程去计算返回值，而当前线程呢，在使用这个返回值之前可以做其他的操作，等到需要这个返回值时，再通过Future得到。

